/* THIS FILE IS AUTOGENERATED FROM MozIcc.webidl BY Codegen.py - DO NOT EDIT */

#ifndef mozilla_dom_MozIccBinding_h
#define mozilla_dom_MozIccBinding_h

#include "js/RootingAPI.h"
#include "jspubtd.h"
#include "mozilla/ErrorResult.h"
#include "mozilla/dom/BindingDeclarations.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/UnionMember.h"

namespace mozilla {
namespace dom {

class CdmaIccInfo;
class GsmIccInfo;
class Icc;
struct IccAtoms;
struct IccCardLockRetryCountAtoms;
struct IccCardLockStatusAtoms;
class IccInfo;
struct IccSetCardLockOptionsAtoms;
struct IccUnlockCardLockOptionsAtoms;
struct NativePropertyHooks;
class OwningMozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfo;
class ProtoAndIfaceCache;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

enum class IccCardState : uint32_t {
  Unknown,
  Ready,
  PinRequired,
  PukRequired,
  PermanentBlocked,
  PersonalizationInProgress,
  PersonalizationReady,
  NetworkLocked,
  NetworkSubsetLocked,
  CorporateLocked,
  ServiceProviderLocked,
  SimPersonalizationLocked,
  NetworkPukRequired,
  NetworkSubsetPukRequired,
  CorporatePukRequired,
  ServiceProviderPukRequired,
  SimPersonalizationPukRequired,
  Network1Locked,
  Network2Locked,
  HrpdNetworkLocked,
  RuimCorporateLocked,
  RuimServiceProviderLocked,
  RuimPersonalizationLocked,
  Network1PukRequired,
  Network2PukRequired,
  HrpdNetworkPukRequired,
  RuimCorporatePukRequired,
  RuimServiceProviderPukRequired,
  RuimPersonalizationPukRequired,
  Illegal,
  EndGuard_
};

namespace IccCardStateValues {
extern const EnumEntry strings[31];
} // namespace IccCardStateValues


enum class IccLockType : uint32_t {
  Pin,
  Pin2,
  Puk,
  Puk2,
  Nck,
  Nsck,
  Nck1,
  Nck2,
  Hnck,
  Cck,
  Spck,
  Pck,
  Rcck,
  Rspck,
  NckPuk,
  NsckPuk,
  Nck1Puk,
  Nck2Puk,
  HnckPuk,
  CckPuk,
  SpckPuk,
  PckPuk,
  RcckPuk,
  RspckPuk,
  Fdn,
  EndGuard_
};

namespace IccLockTypeValues {
extern const EnumEntry strings[26];
} // namespace IccLockTypeValues


enum class IccContactType : uint32_t {
  Adn,
  Fdn,
  Sdn,
  EndGuard_
};

namespace IccContactTypeValues {
extern const EnumEntry strings[4];
} // namespace IccContactTypeValues


enum class IccMvnoType : uint32_t {
  Imsi,
  Spn,
  Gid,
  EndGuard_
};

namespace IccMvnoTypeValues {
extern const EnumEntry strings[4];
} // namespace IccMvnoTypeValues


enum class IccService : uint32_t {
  Fdn,
  EndGuard_
};

namespace IccServiceValues {
extern const EnumEntry strings[2];
} // namespace IccServiceValues


void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback, OwningMozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfo& aUnion, const char* aName, uint32_t aFlags = 0);


void
ImplCycleCollectionUnlink(OwningMozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfo& aUnion);


struct IccCardLockRetryCount : public DictionaryBase
{
  Optional<int32_t> mRetryCount;

  IccCardLockRetryCount();

  explicit inline IccCardLockRetryCount(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline IccCardLockRetryCount(const IccCardLockRetryCount& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const IccCardLockRetryCount& aOther);

private:
  static bool
  InitIds(JSContext* cx, IccCardLockRetryCountAtoms* atomsCache);
};

namespace binding_detail {
struct FastIccCardLockRetryCount : public IccCardLockRetryCount
{
  inline FastIccCardLockRetryCount()
    : IccCardLockRetryCount(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct IccCardLockStatus : public DictionaryBase
{
  Optional<bool> mEnabled;

  IccCardLockStatus();

  explicit inline IccCardLockStatus(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline IccCardLockStatus(const IccCardLockStatus& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const IccCardLockStatus& aOther);

private:
  static bool
  InitIds(JSContext* cx, IccCardLockStatusAtoms* atomsCache);
};

namespace binding_detail {
struct FastIccCardLockStatus : public IccCardLockStatus
{
  inline FastIccCardLockStatus()
    : IccCardLockStatus(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct IccSetCardLockOptions : public DictionaryBase
{
  Optional<bool> mEnabled;
  IccLockType mLockType;
  nsString mNewPin;
  nsString mPin;
  nsString mPin2;

  IccSetCardLockOptions();

  explicit inline IccSetCardLockOptions(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline IccSetCardLockOptions(const IccSetCardLockOptions& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const IccSetCardLockOptions& aOther);

private:
  static bool
  InitIds(JSContext* cx, IccSetCardLockOptionsAtoms* atomsCache);
};

namespace binding_detail {
struct FastIccSetCardLockOptions : public IccSetCardLockOptions
{
  inline FastIccSetCardLockOptions()
    : IccSetCardLockOptions(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct IccUnlockCardLockOptions : public DictionaryBase
{
  IccLockType mLockType;
  nsString mNewPin;
  nsString mPin;
  nsString mPuk;

  IccUnlockCardLockOptions();

  explicit inline IccUnlockCardLockOptions(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline IccUnlockCardLockOptions(const IccUnlockCardLockOptions& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const IccUnlockCardLockOptions& aOther);

private:
  static bool
  InitIds(JSContext* cx, IccUnlockCardLockOptionsAtoms* atomsCache);
};

namespace binding_detail {
struct FastIccUnlockCardLockOptions : public IccUnlockCardLockOptions
{
  inline FastIccUnlockCardLockOptions()
    : IccUnlockCardLockOptions(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


class MozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfo
{
  friend class MozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfoArgument;
  enum Type
  {
    eUninitialized,
    eMozIccInfo,
    eMozGsmIccInfo,
    eMozCdmaIccInfo
  };

  union Value
  {
    UnionMember<NonNull<mozilla::dom::IccInfo> > mMozIccInfo;
    UnionMember<NonNull<mozilla::dom::GsmIccInfo> > mMozGsmIccInfo;
    UnionMember<NonNull<mozilla::dom::CdmaIccInfo> > mMozCdmaIccInfo;

  };

  Type mType;
  Value mValue;

  MozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfo(const MozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfo&) = delete;
  void operator=(const MozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfo) = delete;
public:
  explicit inline MozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfo()
    : mType(eUninitialized)
  {
  }

  inline ~MozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfo()
  {
    Uninit();
  }

  inline NonNull<mozilla::dom::IccInfo>&
  RawSetAsMozIccInfo()
  {
    if (mType == eMozIccInfo) {
      return mValue.mMozIccInfo.Value();
    }
    MOZ_ASSERT(mType == eUninitialized);
    mType = eMozIccInfo;
    return mValue.mMozIccInfo.SetValue();
  }

  inline NonNull<mozilla::dom::IccInfo>&
  SetAsMozIccInfo()
  {
    if (mType == eMozIccInfo) {
      return mValue.mMozIccInfo.Value();
    }
    Uninit();
    mType = eMozIccInfo;
    return mValue.mMozIccInfo.SetValue();
  }

  inline bool
  IsMozIccInfo() const
  {
    return mType == eMozIccInfo;
  }

  inline NonNull<mozilla::dom::IccInfo>&
  GetAsMozIccInfo()
  {
    MOZ_ASSERT(IsMozIccInfo(), "Wrong type!");
    return mValue.mMozIccInfo.Value();
  }

  inline mozilla::dom::IccInfo&
  GetAsMozIccInfo() const
  {
    MOZ_ASSERT(IsMozIccInfo(), "Wrong type!");
    return mValue.mMozIccInfo.Value();
  }

  inline NonNull<mozilla::dom::GsmIccInfo>&
  RawSetAsMozGsmIccInfo()
  {
    if (mType == eMozGsmIccInfo) {
      return mValue.mMozGsmIccInfo.Value();
    }
    MOZ_ASSERT(mType == eUninitialized);
    mType = eMozGsmIccInfo;
    return mValue.mMozGsmIccInfo.SetValue();
  }

  inline NonNull<mozilla::dom::GsmIccInfo>&
  SetAsMozGsmIccInfo()
  {
    if (mType == eMozGsmIccInfo) {
      return mValue.mMozGsmIccInfo.Value();
    }
    Uninit();
    mType = eMozGsmIccInfo;
    return mValue.mMozGsmIccInfo.SetValue();
  }

  inline bool
  IsMozGsmIccInfo() const
  {
    return mType == eMozGsmIccInfo;
  }

  inline NonNull<mozilla::dom::GsmIccInfo>&
  GetAsMozGsmIccInfo()
  {
    MOZ_ASSERT(IsMozGsmIccInfo(), "Wrong type!");
    return mValue.mMozGsmIccInfo.Value();
  }

  inline mozilla::dom::GsmIccInfo&
  GetAsMozGsmIccInfo() const
  {
    MOZ_ASSERT(IsMozGsmIccInfo(), "Wrong type!");
    return mValue.mMozGsmIccInfo.Value();
  }

  inline NonNull<mozilla::dom::CdmaIccInfo>&
  RawSetAsMozCdmaIccInfo()
  {
    if (mType == eMozCdmaIccInfo) {
      return mValue.mMozCdmaIccInfo.Value();
    }
    MOZ_ASSERT(mType == eUninitialized);
    mType = eMozCdmaIccInfo;
    return mValue.mMozCdmaIccInfo.SetValue();
  }

  inline NonNull<mozilla::dom::CdmaIccInfo>&
  SetAsMozCdmaIccInfo()
  {
    if (mType == eMozCdmaIccInfo) {
      return mValue.mMozCdmaIccInfo.Value();
    }
    Uninit();
    mType = eMozCdmaIccInfo;
    return mValue.mMozCdmaIccInfo.SetValue();
  }

  inline bool
  IsMozCdmaIccInfo() const
  {
    return mType == eMozCdmaIccInfo;
  }

  inline NonNull<mozilla::dom::CdmaIccInfo>&
  GetAsMozCdmaIccInfo()
  {
    MOZ_ASSERT(IsMozCdmaIccInfo(), "Wrong type!");
    return mValue.mMozCdmaIccInfo.Value();
  }

  inline mozilla::dom::CdmaIccInfo&
  GetAsMozCdmaIccInfo() const
  {
    MOZ_ASSERT(IsMozCdmaIccInfo(), "Wrong type!");
    return mValue.mMozCdmaIccInfo.Value();
  }

  inline void
  Uninit()
  {
    switch (mType) {
      case eUninitialized: {
        break;
      }
      case eMozIccInfo: {
        DestroyMozIccInfo();
        break;
      }
      case eMozGsmIccInfo: {
        DestroyMozGsmIccInfo();
        break;
      }
      case eMozCdmaIccInfo: {
        DestroyMozCdmaIccInfo();
        break;
      }
    }
  }

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

private:
  inline void
  DestroyMozIccInfo()
  {
    MOZ_ASSERT(IsMozIccInfo(), "Wrong type!");
    mValue.mMozIccInfo.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyMozGsmIccInfo()
  {
    MOZ_ASSERT(IsMozGsmIccInfo(), "Wrong type!");
    mValue.mMozGsmIccInfo.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyMozCdmaIccInfo()
  {
    MOZ_ASSERT(IsMozCdmaIccInfo(), "Wrong type!");
    mValue.mMozCdmaIccInfo.Destroy();
    mType = eUninitialized;
  }
};


class OwningMozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfo : public AllOwningUnionBase
{
  friend void ImplCycleCollectionUnlink(OwningMozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfo& aUnion);
  enum Type
  {
    eUninitialized,
    eMozIccInfo,
    eMozGsmIccInfo,
    eMozCdmaIccInfo
  };

  union Value
  {
    UnionMember<OwningNonNull<mozilla::dom::IccInfo> > mMozIccInfo;
    UnionMember<OwningNonNull<mozilla::dom::GsmIccInfo> > mMozGsmIccInfo;
    UnionMember<OwningNonNull<mozilla::dom::CdmaIccInfo> > mMozCdmaIccInfo;

  };

  Type mType;
  Value mValue;

public:
  explicit inline OwningMozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfo()
    : mType(eUninitialized)
  {
  }

  explicit inline OwningMozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfo(const OwningMozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfo& aOther)
    : mType(eUninitialized)
  {
    *this = aOther;
  }

  inline ~OwningMozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfo()
  {
    Uninit();
  }

  OwningNonNull<mozilla::dom::IccInfo>&
  RawSetAsMozIccInfo();

  OwningNonNull<mozilla::dom::IccInfo>&
  SetAsMozIccInfo();

  bool
  TrySetToMozIccInfo(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsMozIccInfo() const
  {
    return mType == eMozIccInfo;
  }

  inline OwningNonNull<mozilla::dom::IccInfo>&
  GetAsMozIccInfo()
  {
    MOZ_ASSERT(IsMozIccInfo(), "Wrong type!");
    return mValue.mMozIccInfo.Value();
  }

  inline OwningNonNull<mozilla::dom::IccInfo> const &
  GetAsMozIccInfo() const
  {
    MOZ_ASSERT(IsMozIccInfo(), "Wrong type!");
    return mValue.mMozIccInfo.Value();
  }

  OwningNonNull<mozilla::dom::GsmIccInfo>&
  RawSetAsMozGsmIccInfo();

  OwningNonNull<mozilla::dom::GsmIccInfo>&
  SetAsMozGsmIccInfo();

  bool
  TrySetToMozGsmIccInfo(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsMozGsmIccInfo() const
  {
    return mType == eMozGsmIccInfo;
  }

  inline OwningNonNull<mozilla::dom::GsmIccInfo>&
  GetAsMozGsmIccInfo()
  {
    MOZ_ASSERT(IsMozGsmIccInfo(), "Wrong type!");
    return mValue.mMozGsmIccInfo.Value();
  }

  inline OwningNonNull<mozilla::dom::GsmIccInfo> const &
  GetAsMozGsmIccInfo() const
  {
    MOZ_ASSERT(IsMozGsmIccInfo(), "Wrong type!");
    return mValue.mMozGsmIccInfo.Value();
  }

  OwningNonNull<mozilla::dom::CdmaIccInfo>&
  RawSetAsMozCdmaIccInfo();

  OwningNonNull<mozilla::dom::CdmaIccInfo>&
  SetAsMozCdmaIccInfo();

  bool
  TrySetToMozCdmaIccInfo(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsMozCdmaIccInfo() const
  {
    return mType == eMozCdmaIccInfo;
  }

  inline OwningNonNull<mozilla::dom::CdmaIccInfo>&
  GetAsMozCdmaIccInfo()
  {
    MOZ_ASSERT(IsMozCdmaIccInfo(), "Wrong type!");
    return mValue.mMozCdmaIccInfo.Value();
  }

  inline OwningNonNull<mozilla::dom::CdmaIccInfo> const &
  GetAsMozCdmaIccInfo() const
  {
    MOZ_ASSERT(IsMozCdmaIccInfo(), "Wrong type!");
    return mValue.mMozCdmaIccInfo.Value();
  }

  void
  Uninit();

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceUnion(JSTracer* trc);

  void
  operator=(const OwningMozIccInfoOrMozGsmIccInfoOrMozCdmaIccInfo& aOther);

private:
  void
  DestroyMozIccInfo();

  void
  DestroyMozGsmIccInfo();

  void
  DestroyMozCdmaIccInfo();
};


namespace MozIccBinding {

  typedef mozilla::dom::Icc NativeType;

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  JSObject*
  DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal);

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::Icc* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  JS::Handle<JSObject*>
  GetProtoObjectHandle(JSContext* aCx, JS::Handle<JSObject*> aGlobal);

  JS::Handle<JSObject*>
  GetConstructorObjectHandle(JSContext* aCx, JS::Handle<JSObject*> aGlobal, bool aDefineOnGlobal = true);

  JSObject*
  GetConstructorObject(JSContext* aCx, JS::Handle<JSObject*> aGlobal);

} // namespace MozIccBinding



} // namespace dom
} // namespace mozilla

#endif // mozilla_dom_MozIccBinding_h
