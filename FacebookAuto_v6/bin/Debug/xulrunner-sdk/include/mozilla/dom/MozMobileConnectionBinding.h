/* THIS FILE IS AUTOGENERATED FROM MozMobileConnection.webidl BY Codegen.py - DO NOT EDIT */

#ifndef mozilla_dom_MozMobileConnectionBinding_h
#define mozilla_dom_MozMobileConnectionBinding_h

#include "js/RootingAPI.h"
#include "jspubtd.h"
#include "mozilla/ErrorResult.h"
#include "mozilla/dom/BindingDeclarations.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/UnionMember.h"

namespace mozilla {
namespace dom {

class MobileConnection;
struct MobileConnectionAtoms;
struct MozCallBarringOptionsAtoms;
struct MozCallForwardingOptionsAtoms;
struct MozClirStatusAtoms;
struct MozMMIResultAtoms;
struct NativePropertyHooks;
class OwningUnsignedShortOrObject;
class ProtoAndIfaceCache;
class UnsignedShortOrObject;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

enum class MobileNetworkSelectionMode : uint32_t {
  Automatic,
  Manual,
  EndGuard_
};

namespace MobileNetworkSelectionModeValues {
extern const EnumEntry strings[3];
} // namespace MobileNetworkSelectionModeValues


enum class MobileRadioState : uint32_t {
  Enabling,
  Enabled,
  Disabling,
  Disabled,
  EndGuard_
};

namespace MobileRadioStateValues {
extern const EnumEntry strings[5];
} // namespace MobileRadioStateValues


enum class MobileNetworkType : uint32_t {
  Gsm,
  Wcdma,
  Cdma,
  Evdo,
  Lte,
  EndGuard_
};

namespace MobileNetworkTypeValues {
extern const EnumEntry strings[6];
} // namespace MobileNetworkTypeValues


enum class MobilePreferredNetworkType : uint32_t {
  Wcdma_gsm,
  Gsm,
  Wcdma,
  Wcdma_gsm_auto,
  Cdma_evdo,
  Cdma,
  Evdo,
  Wcdma_gsm_cdma_evdo,
  Lte_cdma_evdo,
  Lte_wcdma_gsm,
  Lte_wcdma_gsm_cdma_evdo,
  Lte,
  Lte_wcdma,
  EndGuard_
};

namespace MobilePreferredNetworkTypeValues {
extern const EnumEntry strings[14];
} // namespace MobilePreferredNetworkTypeValues


enum class MobileRoamingMode : uint32_t {
  Home,
  Affiliated,
  Any,
  EndGuard_
};

namespace MobileRoamingModeValues {
extern const EnumEntry strings[4];
} // namespace MobileRoamingModeValues


struct MozCallBarringOptions : public DictionaryBase
{
  Optional<Nullable<bool>> mEnabled;
  Optional<nsString> mNewPin;
  Optional<nsString> mPassword;
  Optional<nsString> mPin;
  Optional<Nullable<uint16_t>> mProgram;
  Optional<Nullable<uint16_t>> mServiceClass;

  MozCallBarringOptions();

  explicit inline MozCallBarringOptions(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline MozCallBarringOptions(const MozCallBarringOptions& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozCallBarringOptions& aOther);

private:
  static bool
  InitIds(JSContext* cx, MozCallBarringOptionsAtoms* atomsCache);
};

namespace binding_detail {
struct FastMozCallBarringOptions : public MozCallBarringOptions
{
  inline FastMozCallBarringOptions()
    : MozCallBarringOptions(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozCallForwardingOptions : public DictionaryBase
{
  Optional<Nullable<uint16_t>> mAction;
  Optional<Nullable<bool>> mActive;
  Optional<nsString> mNumber;
  Optional<Nullable<uint16_t>> mReason;
  Optional<Nullable<uint16_t>> mServiceClass;
  Optional<Nullable<uint16_t>> mTimeSeconds;

  MozCallForwardingOptions();

  explicit inline MozCallForwardingOptions(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline MozCallForwardingOptions(const MozCallForwardingOptions& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozCallForwardingOptions& aOther);

private:
  static bool
  InitIds(JSContext* cx, MozCallForwardingOptionsAtoms* atomsCache);
};

namespace binding_detail {
struct FastMozCallForwardingOptions : public MozCallForwardingOptions
{
  inline FastMozCallForwardingOptions()
    : MozCallForwardingOptions(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozClirStatus : public DictionaryBase
{
  Optional<uint16_t> mM;
  Optional<uint16_t> mN;

  MozClirStatus();

  explicit inline MozClirStatus(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline MozClirStatus(const MozClirStatus& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozClirStatus& aOther);

private:
  static bool
  InitIds(JSContext* cx, MozClirStatusAtoms* atomsCache);
};

namespace binding_detail {
struct FastMozClirStatus : public MozClirStatus
{
  inline FastMozClirStatus()
    : MozClirStatus(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


class UnsignedShortOrObject
{
  friend class UnsignedShortOrObjectArgument;
  enum Type
  {
    eUninitialized,
    eUnsignedShort,
    eObject
  };

  union Value
  {
    UnionMember<uint16_t > mUnsignedShort;
    UnionMember<JS::Rooted<JSObject*> > mObject;

  };

  Type mType;
  Value mValue;

  UnsignedShortOrObject(const UnsignedShortOrObject&) = delete;
  void operator=(const UnsignedShortOrObject) = delete;
public:
  explicit inline UnsignedShortOrObject()
    : mType(eUninitialized)
  {
  }

  inline ~UnsignedShortOrObject()
  {
    Uninit();
  }

  inline uint16_t&
  RawSetAsUnsignedShort()
  {
    if (mType == eUnsignedShort) {
      return mValue.mUnsignedShort.Value();
    }
    MOZ_ASSERT(mType == eUninitialized);
    mType = eUnsignedShort;
    return mValue.mUnsignedShort.SetValue();
  }

  inline uint16_t&
  SetAsUnsignedShort()
  {
    if (mType == eUnsignedShort) {
      return mValue.mUnsignedShort.Value();
    }
    MOZ_ASSERT(mType != eObject, "This will not play well with Rooted");
    Uninit();
    mType = eUnsignedShort;
    return mValue.mUnsignedShort.SetValue();
  }

  inline bool
  IsUnsignedShort() const
  {
    return mType == eUnsignedShort;
  }

  inline uint16_t&
  GetAsUnsignedShort()
  {
    MOZ_ASSERT(IsUnsignedShort(), "Wrong type!");
    return mValue.mUnsignedShort.Value();
  }

  inline uint16_t
  GetAsUnsignedShort() const
  {
    MOZ_ASSERT(IsUnsignedShort(), "Wrong type!");
    return mValue.mUnsignedShort.Value();
  }

  inline bool
  IsObject() const
  {
    return mType == eObject;
  }

  inline JS::Rooted<JSObject*>&
  GetAsObject()
  {
    MOZ_ASSERT(IsObject(), "Wrong type!");
    return mValue.mObject.Value();
  }

  inline JSObject*
  GetAsObject() const
  {
    MOZ_ASSERT(IsObject(), "Wrong type!");
    return mValue.mObject.Value();
  }

  inline void
  Uninit()
  {
    switch (mType) {
      case eUninitialized: {
        break;
      }
      case eUnsignedShort: {
        DestroyUnsignedShort();
        break;
      }
      case eObject: {
        DestroyObject();
        break;
      }
    }
  }

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

private:
  inline void
  DestroyUnsignedShort()
  {
    MOZ_ASSERT(IsUnsignedShort(), "Wrong type!");
    mValue.mUnsignedShort.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyObject()
  {
    MOZ_ASSERT(IsObject(), "Wrong type!");
    mValue.mObject.Destroy();
    mType = eUninitialized;
  }
};


class OwningUnsignedShortOrObject : public AllOwningUnionBase
{
  friend void ImplCycleCollectionUnlink(OwningUnsignedShortOrObject& aUnion);
  enum Type
  {
    eUninitialized,
    eUnsignedShort,
    eObject
  };

  union Value
  {
    UnionMember<uint16_t > mUnsignedShort;
    UnionMember<JSObject* > mObject;

  };

  Type mType;
  Value mValue;

  OwningUnsignedShortOrObject(const OwningUnsignedShortOrObject&) = delete;
  void operator=(const OwningUnsignedShortOrObject) = delete;
public:
  explicit inline OwningUnsignedShortOrObject()
    : mType(eUninitialized)
  {
  }

  inline ~OwningUnsignedShortOrObject()
  {
    Uninit();
  }

  uint16_t&
  RawSetAsUnsignedShort();

  uint16_t&
  SetAsUnsignedShort();

  bool
  TrySetToUnsignedShort(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsUnsignedShort() const
  {
    return mType == eUnsignedShort;
  }

  inline uint16_t&
  GetAsUnsignedShort()
  {
    MOZ_ASSERT(IsUnsignedShort(), "Wrong type!");
    return mValue.mUnsignedShort.Value();
  }

  inline uint16_t const &
  GetAsUnsignedShort() const
  {
    MOZ_ASSERT(IsUnsignedShort(), "Wrong type!");
    return mValue.mUnsignedShort.Value();
  }

  JSObject*&
  RawSetAsObject();

  JSObject*&
  SetAsObject();

  inline bool
  SetToObject(JSContext* cx, JSObject* obj, bool passedToJSImpl = false)
  {
    MOZ_ASSERT(mType == eUninitialized);
    mValue.mObject.SetValue(obj);
    mType = eObject;
    if (passedToJSImpl && !CallerSubsumes(obj)) {
      ThrowErrorMessage(cx, MSG_PERMISSION_DENIED_TO_PASS_ARG, "%s");
      return false;
    }
    return true;
  }

  inline bool
  IsObject() const
  {
    return mType == eObject;
  }

  inline JSObject*&
  GetAsObject()
  {
    MOZ_ASSERT(IsObject(), "Wrong type!");
    return mValue.mObject.Value();
  }

  inline JSObject* const &
  GetAsObject() const
  {
    MOZ_ASSERT(IsObject(), "Wrong type!");
    return mValue.mObject.Value();
  }

  void
  Uninit();

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceUnion(JSTracer* trc);

private:
  void
  DestroyUnsignedShort();

  void
  DestroyObject();
};


struct MozMMIResult : public DictionaryBase
{
  Optional<OwningUnsignedShortOrObject> mAdditionalInformation;
  nsString mServiceCode;
  nsString mStatusMessage;
  bool mSuccess;

  MozMMIResult();

  explicit inline MozMMIResult(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  MozMMIResult(const MozMMIResult&) = delete;
  void operator=(const MozMMIResult) = delete;

  static bool
  InitIds(JSContext* cx, MozMMIResultAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);
};

namespace binding_detail {
struct FastMozMMIResult : public MozMMIResult
{
  inline FastMozMMIResult()
    : MozMMIResult(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


namespace MozMobileConnectionBinding {

  typedef mozilla::dom::MobileConnection NativeType;

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  JSObject*
  DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal);

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::MobileConnection* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  void
  ClearCachedSupportedNetworkTypesValue(mozilla::dom::MobileConnection* aObject);

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  JS::Handle<JSObject*>
  GetProtoObjectHandle(JSContext* aCx, JS::Handle<JSObject*> aGlobal);

  JS::Handle<JSObject*>
  GetConstructorObjectHandle(JSContext* aCx, JS::Handle<JSObject*> aGlobal, bool aDefineOnGlobal = true);

  JSObject*
  GetConstructorObject(JSContext* aCx, JS::Handle<JSObject*> aGlobal);

} // namespace MozMobileConnectionBinding



} // namespace dom
} // namespace mozilla

#endif // mozilla_dom_MozMobileConnectionBinding_h
